\input texinfo   @c -*-texinfo-*-
@c
@c $Id$
@c
@setfilename eieio.info
@settitle Enhanced Implementation of Emacs Interpreted Objects

@ifinfo
@format
START-INFO-DIR-ENTRY
* eieio: (eieio).       Objects for Emacs
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@titlepage
@sp 10
@center @titlefont{eieio}
@vskip 0pt plus 1 fill
Copyright @copyright{} 1995,1996,1998, 1999 Eric M. Ludlam
@end titlepage


@node Top, , , (dir)Top
@comment  node-name,  next,  previous,  up

EIEIO is a framework for writing object oriented applications in emacs
lisp, and is a result of my taking various object oriented classes at
work and my attempt to understand some of it better by implementing it.
The real reason I started eieio is because someone in one of my classes
said "I bet emacs can't do that!".  Well then, I just had to prove them
wrong!

@menu
* Introduction::          Why use eieio?  Basic overview, samples list.
* CLOS compatibility::    What are the differences?
* Building Classes::      How to write out new class structures.
* Default Superclass::    The grand-daddy of all superclasses.
* Making New Objects::    How to construct new objects.
* Accessing Fields::      How to access a field.
* Writing Methods::       How to write a CLOS style method.
* Writing Methods::       How to write an embedded class method.
* Predicates::            Class-p, Object-p, etc-p.
* Association Lists::     List of objects as assoc lists.
* Introspection::         Looking inside a class.
* Signals::               When you make errors
* Browsing::              Browsing your class lists.
* Class Values::          Displaying information about a class or object.
* Customizing::           Customizing objects.
* Documentation::         Automatically creating texinfo documentation
* Demo Programs::         Some examples using eieio.
* Function Index::
@end menu

As of this writing, updates can be found at:
  @uref{ftp://ftp.ultranet.com/pub/zappo}.

@node Introduction, CLOS compatibility, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

  One thing emacs lisp does not support is structured data organization,
and restricted function access unless one uses the cl package.  As a
programmer it's easy to break up a program into modules, and say "I
won't access function or variable XYZ anywhere but here", but it's not
protected from other programmers doing an apropos and thinking "Hey,
this is a useful function and I will use it".  Then a program is
upgraded, and the second programmer is unhappy.

  I've have attempted to make EIEIO CLOS compatible (Common Lisp Object
System).  This compatibility is only at a fairly basic level.

@section What EIEIO supports

@enumerate
@item
A structured framework for the creation of basic classes with attributes
and methods using singular inheritance similar to CLOS.
@item
Public and private classifications for slots (extensions to CLOS)
@item
Customization support in a class (extension to CLOS)
@item
Method definitions similar to CLOS.
@item
Simple and complex class browsers.
@item
Edebug support.
@item
Imenu updates
@item
Byte compilation support of methods
@item
Complex documentation maintenance for emacs symbols
@item
Automatic texinfo documentation generator
@end enumerate

@section What EIEIO doesn't support

@table @asis
@item Multiple inheritance
We could say EIEIO is still in the Fungal stages of development as a
class can have but one parent.  (This is being worked on)
@item Complete @code{defclass} tag support
All CLOS tags are currently supported, but some are not currently
implemented correctly.
@item Mock object initializeres
Each class contains a mock object used for fast initialization of
instantiated objects.  Using functions with side effects on object slot
values can potentially cause modifications in the mock object.  EIEIO
should use a deep copy but currently does not.
@item :AROUND method tag
@end table

@section EIEIO example programs that are almost useful.

@table @asis
@item tree
Draw a structured tree by building a series of embeded lists of
`tree-node' class objects.  Includes the functions `eieio-class-tree' to
browse your current eieio inheritance structure
@item call-tree
Pass it an elisp function (not byte compiled) to generate a call tree
using the tree tool
@item chart
Uses eieio to manage charts/axis/sequences, and allows display of simple
bar-charts.  Example programs are available displaying emacs memory
usage and list occupation, in addition to file counts and size charts.
Theres even a sample that will display a chart of who sends you the most
email!  See doc-string for `chart-bar-quickie' to make your own bar
charts easily.
@end table

@section EIEIO wish list

@enumerate
@item
More CLOS compatibility.
@item
Integrate in the desired built-in methods into the object browser.
@item
Create some objects over pre-existing emacs-lisp stuff for fun, like
faces, processes, buffers, frames and windows as examples.
@end enumerate

@node CLOS compatibility, Building Classes, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter CLOS compatibility

As I write this, it is important to know that I have just recently
learned some of the CLOS syntax, but have never used it myself.  I'm
primarilly and emacs-lisp hacker who wrote eieio to help myself learn
some of the mechanics of Object Oriented programming.

Currently, the following functions should behave as expected from CLOS,
or are mostly compatible.

@table @code
@item defclass
All slot keywords are avaliable but not all work correctly.  Only single
inheritance is currently supported.  Slot keyword differences are:

@table @asis
@item :reader, and :writer tags
Create methods that throw errors instead of
creating an unqualified method.
@item :accessor
should create an unqualified method to access a slot, but
instead pre-builds a method that gets the slot's value.
@item :type
specifier uses the @code{typep} function from the @file{cl}
package.  @xref{(cl)Type Predicates}. It therefore has the same issues as
that package.
@item  :initform specifier
is implemented correctly, but slots are not `unbound', and merely gain a
value of @code{nil}
@end table

@item make-instance
Make instance works as expected, however it just uses the EIEIO instance
creator automatically created when a new class is generated.
@xref{Making New Objects}.
@item slot-value
Accesses the value of a named slot within an object
@item defgeneric
Creates the desired symbol, and accepts most of the expected arguments
@item defmethod
Calls defgeneric, and accepts most of the expected arguments.  Only the
first argument to the created method may be typecast, though any
argument can be syntactically typecast.  (And promptly ignored)  To
typecast against a class, the class must exist before defmethod is called.
@item call-next-method
Inside a method, calls the next available method up the inheritance tree
for the given object.  This is different than that found in CLOS because
in eieio this function accepts replacement arguments.  This permits
subclasses to modify arguments as they are passed up the tree.  If no
arguments are given, the expected CLOS behavior is used.
@item setf
If the common-lisp subsystem is loaded, the setf parameters are also
loaded so the form @code{(setf (slot-value object value) t)} should
work.
@end table

Some top-level CLOS functions which I am aware of but are not yet
defined in EIEIO which are defined in CLOS.

@table @asis
@item describe
Pretty print an object.  Can be found as @code{eieio-describe-class} for a
bufferized version.
@end table

When creating a new class (@pxref{Building Classes}) there are several
keywords supported by EIEIO.

In EIEIO tags are in lower case, not mixed case.

@node Building Classes, Default Superclass, CLOS compatibility, Top
@comment  node-name,  next,  previous,  up
@chapter Building Classes

A class in EIEIO has a similar structure to that found in other
languages.  A new class is created with @code{defclass}

@defun defclass class-name superclass-list field-list doc-string

The format for this defun is specified by CLOS, and EIEIO conforms in
structure.

Creates a new class called @code{class-name}. The created variable's
documentation string is set to a modified version of @var{doc-string}.
Each time a slot is defined the variables documentation string is
updated to include the methods documentation as well.

The parent class for @code{class-name} must be a list.  At this time
only the first element of that list is used.  In the future, multiple
inheritance may be supported.

The field list is a list of lists.  Each sublist defines an attribute.
These lists are of the form @code{(name :tag1 value1 :tag2 value2 :tagn
valuen)}.  Some valid tags are:

@table @asis
@item :initarg
The argument used during initialization.  @xref{Making New Objects}.
@item :initform
A lisp expression used to generate the default value for this slot.
@item :accessor
Name of a generic function which can be used to fetch the value of this slot.
@item :writer
Name of a generic function which will write this slot.
@item :reader
Name of a generic function which will read this slot.
@item :type
An unquoted type specifier used to validate data set into this slot.
@xref{(cl)Type Predicates}.
@item :allocation
Unsupported: Either :class or :instance (defaults to :instance) used to
specify how data is stored.
@item :documentation
Documentation detailing the use of this slot.
@item :custom
A custom :type specifier used when editing an object of this type.
@item :protection
A CLOS unsupported specifier which indicates that only methods of this
class may access this slot.
@end table

@ref{CLOS compatibility}, for more details on CLOS tags versus EIEIO
specific tags.

The whole definition may look like this:
@example
(defclass data-object ()
  ((value :initarg :value
	  :initform nil
	  :accessor get-value
	  :documentation "Lisp object which represents the data this 
object maintains."
	  :protection private)
   (reference :initarg :reference
	      :initform nil
              :type list
              :custom (repeat object)
	      :documentation "List of objects looking at me.  The method 
`update-symbol' is called for each member of `reference' whenever 
`value' is modified."
	      :protection private)
   )
  "Data object which tracks referencers.")
@end example

@end defun

@node Default Superclass, Making New Objects, Building Classes, Top
@comment  node-name,  next,  previous,  up
@chapter Default Superclass

All defined classes, if created as a superclass (With no specified
parent class) will actually inherit from a special superclass stored in
@code{eieio-default-superclass}.  This superclass is actually quite
simple, but with it, certain default methods or attributes can be added
to all objects at any time, without updating their code in the future
(If there is a change).  In CLOS, this would be named
@code{STANDARD-OBJECT} and is aliased.

Currently, the default superclass is defined as follows:

@example
(defclass eieio-default-superclass nil
  nil
  )
 "Default class used as parent class for superclasses.  It's
fields are automatically adopted by such superclasses but not stored
in the `parent' field.  When searching for attributes or methods, when
the last parent is found, the search will recurse to this class.")
@end example

When creating an object of any type, you can use it's constructor, or
@code{make-instance}.  This, in turns calls @code{shared-initialize}.

@defun initialize-instance obj &rest fields
Initialize @var{obj}.  Sets fields of @var{obj} with @var{fields} which
is a list of name/value pairs.  These are actually just passed to
@code{shared-initialize}.
@end defun

@defun shared-initialize obj &rest fields
Sets fields of @var{obj} with @var{fields} which is a list of name/value
pairs.
@end defun

@defun clone obj &rest params
Make a deep copy of @var{obj}.  Once this copy is made, make
modifications specified by @var{params}.  @var{params} uses the same
format as the @var{fields} of @code{initialize-instance}.  The only
other change is to modify the name with an incrementing numeric.
@end defun

@defun object-print obj &rest strings
Construct a printing lisp symbol for @var{OBJ}.  This would look like:
@example
 #<class-name "objname">
@end example
STRINGS are additional parameters passed in by overloading functions to
add more data into the printing abbreviation.

@example
(defclass data-object ()
   (value)
   "Object containing one data slot.")

(defmethod object-print ((this data-object) &optional strings)
  "Return a string with a summary of the data object as part of the name."
  (apply 'call-next-method this 
	 (cons (format " value: %s" (render this)) strings)))
@end example

here is what some output could look like:
@example
(object-print test-object)
   => #<data-object test-object value: 3>
@end example
@end defun

@defun object-write obj &optional comment
Write @var{obj} onto a stream in a readable fashion.  The resulting
output will be lisp code which can be used with @code{read} and
@code{eval} to recover the object.  Only fields with @code{:initarg}s
are written to the stream.
@end defun

@node Making New Objects, Accessing Fields, Default Superclass, Top
@comment  node-name,  next,  previous,  up
@chapter Making New Objects

Once we have defined our classes, it's time to create objects with the
specified structure.  After we call @code{defclass} two new functions
are created, one of which is @code{classname}.  Thus, from the example at
the end of the previous chapter @xref{Building Classes}, we would have
the functions @code{data-object} and @code{data-object-p}.

@defun classname object-name &rest fields

This creates and returns a new object.  This object is not assigned to
anything, and will be garbage collected if not saved.  This object will
be given the string name @var{object-name}.  There can be multiple
objects of the same name, but the name field provides a handy way to
keep track of your objects.  @var{fields} is just all the fields you
wish to preset.  Any field set as such WILL NOT get it's default value,
and any side effects from an attributes default function will not occur.
An example pair would appear simply as @code{:value 1}.  Of course you
can do any valid lispy thing you want with it, such as
@code{:value (if (boundp 'special-symbol) special-symbol nil)}

Example of creating an object from a class, @ref{Building Classes}:

@example
(data-object "test" :value 3 :reference nil)
@end example

@end defun

@node Accessing Fields, Writing Methods, Making New Objects, Top
@comment  node-name,  next,  previous,  up
@chapter Accessing Fields

There are several ways to access field values in an object.  The naming
convention and argument order is similar to that found in elisp for
referencing vectors.  The basics for referencing, setting, and calling
methods are all accounted for.

@defun oset object field value

This sets the value behind @var{field} to @var{value} in @var{object}.
@code{oset} returns @var{value}.
@end defun

@defun oset-default class field value

This sets the slot @var{field} in @var{class} which is initialized with
the @code{:initform} tag to @var{value}.  This will allow a user to set
both public and private defaults after the class has been constructed.
This function is pretty intrusive, and is offered as a way to allow
users to configure the default behavior of packages built with classes
more easily.

For example, if a user wanted all @code{data-objects} (@pxref{Building
Classes}) to inform a special object of his own devising when they
changed, this can be arranged by simply executing this bit of code:

@example
(oset-default data-object referece (list my-special-object))
@end example

@end defun

@defun oref object field

This recalls the value in slot @var{field} in @var{object} and returns
it.
@end defun

@defun oref-default object field

This gets the default value in @var{object}'s class definition for
@code{field}.  This can be different from the value returned by
@code{oref}.  @var{object} can also be a class symbol or an instantiated
object.
@end defun

@defun slot-value object field
This function is mearly an alias for oref
@end defun

When using @code{oref} or @code{oset}, if the value behind @var{field}
is private, then the current scope of operation must be within a method
of the calling object.  The scope is tracked with the variable
@code{this}.  You can set the field @code{this} by making it the name of
your object passed into your methods.  It is not necessary to name your
object @code{this}, or to use private fields.

@defun with-slots entries object forms
Bind ENTRIES lexically to the specified slot values in OBJECT, and
execute FORMS.  In CLOS, it would be possible to set values in OBJECT by
using @code{setf} to assign to these values, but in Emacs, you may only
read the values, or set the local variable to a new value.

@example
(defclass myclass () (x :initarg 1))
(setq mc (make-instance 'myclass))
(with-slots (x) mc x)                      => 1
(with-slots ((something x)) mc something)  => 1
@end example
@end defun

@defun slot-missing object field operation &optional new-valie
This method is called when a there is an attemp to access a slot that
does not exist for a given object.  The default method signals an error
of type @code{invalid-slot-name}.  @xref{Signals}.

You may override this behavior, but it is not expected to return in the
current implementation.
@end defun

@node Writing Methods, Predicates, Accessing Fields, Top
@comment  node-name,  next,  previous,  up
@chapter Writing Methods

Writing a CLOS style method is similar to writing a function, except
some extra options are made available, and there can be multiple
implementations of a single method which interact interestingly with
each other.

Each method created verifies that there is a @dfn{generic method}
available to attach to.  A generic method has no body, and is mearly a
symbol upon which methods are attached.

@defun defgeneric method arglist [doc-string]

@var{method} is the symbol to turn into a function.
@var{arglist} is the default list of arguments to use (not implemented yet)
@var{doc-string} is the documentation used for this symbol

A generic function acts as a place holder for methods.  There is no need
to call defgeneric yourself, as defmethod will call it if necessary.
Currently the argument list is unused.

The function part of a created generic function creates a couple local
variables and then calls @code{eieio-generic-call}.  This is the engine
that makes sure that different method implementations are called in the
correct order.

@code{defgeneric} will prevent you from turning an existing emacs lisp
function into a generic function.
@end defun

@defun defmethod method [:BEFORE | :AFTER] arglist [doc-string] forms

@var{method} is the name of the function to be created.

@var{:BEFORE | :AFTER} represent when this form is to be called.  
If neither of these symbols are present, then the default priority is
before :AFTER and after :BEFORE, and is represented in CLOS as
:PRIMARY.

@code{arglist} is the argument list.  Unlike CLOS, only the FIRST
argument may be type-cast, and it may only be type-cast to an eieio
object.  An arglist such as @code{(a b)} would classify the function as
generic call, which has no object it can talk to (none is passed in) and
mearly allows the creation of side-effects.  If the arglist appears as
@code{((this data-object) b)} then the form is stored as belonging to
the class @code{data-object}.  If two @code{defmethods} appear with
arglists such as @code{(a b)} and @code{(c d)} then one of the
implementations will be overwritten, but generic and multiple type cast
arglists can co-exist.

When called, if there is a method cast against the object's parent
class, but not for that object's class, the parent class' method will be
called.  If there is a method defined for both, only the child's method
is called.

@var{doc-string} is the doc string attached to the implementation.  All
method doc-strings are concatenated into the generic method's function
documentation.

@var{forms} is the body of the function.

@end defun

@defun call-next-method &rest replacement-args

While running insided a CLOS method, calling this function will call the
method associated with the parent of the class of the currently running
method with the same parameters.

Optional arguments REPLACEMENT-ARGS can be used to replace the arguments
the next method would be called with.  Useful if a child class wishes to
add additional behaviours through the modification of the parameters.

@ref{Default Superclass} for example code.

@end defun

In this implementation, not all features of CLOS exist.

@enumerate
@item
There is currently no :AROUND tag.
@item
CLOS allows multiple sets of type-cast arguments, where eieio only
allows the first argument to be cast.
@end enumerate

@node Predicates, Association Lists, Writing Methods, Top
@comment  node-name,  next,  previous,  up
@chapter Predicates and Utilities

Now that we know how to create classes, access fields, and define
methods, it might be useful to verify that everything is doing ok.  To
help with this a plethora of predicates have been created.

@defun class-v class
Return a vector with all the class's important parts in it.  This vector
is not a copy.  Changing this vector changes the class.
@end defun

@defun class-p class
Return @code{t} if @var{class} is a class type.
@end defun

@defun object-p obj
Return @code{t} if @var{obj} is an object.
@end defun

@defun slot-exists-p obj slot
Return Non-@code{nil} if @var{obj} contains @var{slot} in its class.
@end defun

@defun slot-boundp obj slot
In CLOS, an object can have an unbound slot.  EIEIO binds all
slots at instantiation time, thus this function is a macro that calls
@code{slot-exists-p}
@end defun

@defun class-name class
Return a string of the form #<class myclassname> which should look
similar to other lisp objects like buffers and processes.  Printing a
class results only in a symbol.  
@end defun

@defun class-constructor class
Return a symbol used as a constructor for @var{class}.  This way you can
make an object of a passed in class without knowing what it is.  This is
not a part of CLOS.
@end defun

@defun object-name obj
Return a string of the form #<object-class myobjname> for @var{obj}.
This should look like lisp symbols from other parts of emacs such as
buffers and processes, and is shorter and cleaner than printing the
object's vector.  It is more useful to use @code{object-print} to get
and object's print form, as this allows the object to add extra display
information into the symbol.
@end defun

@defun object-class obj
Returns the class symbol from @var{obj}.
@end defun

@defun class-of obj
CLOS symbol which does the same thing as @code{object-class}
@end defun

@defun object-class-fast obj
Same as @code{object-class} except this is a macro, and no
type-checking is performed.
@end defun

@defun object-class-name obj
Returns the symbol of @var{obj}'s class.
@end defun

@defun class-parent class
Returns the direct parent class of @var{class}.  Returns @code{nil} if
it is a superclass.
@end defun

@defun class-parent-fast class
Just like @code{class-parent} except it is a macro and no type checking
is performed.
@end defun

@defun same-class-p obj class
Returns @code{t} if @var{obj}'s class is the same as @var{class}.
@end defun

@defun same-class-fast-p obj class
Same as @code{same-class-p} except this is a macro and no type checking
is performed.
@end defun

@defun obj-of-class-p obj class
Returns @code{t} if @var{obj} inherits anything from @var{class}.  This
is different from @code{same-class-p} because it checks for inheritance.
@end defun

@defun child-of-class-p child class
Returns @code{t} if @var{child} is a subclass of @var{class}.
@end defun

@defun generic-p method-symbol
Returns @code{t} if @code{method-symbol} is a generic function, as
opposed to a regular emacs list function.
@end defun

It is also important to note, that for every created class, a predicate
is created for it.  Thus in our example, the function
@code{data-object-p} is created, and return @code{t} if passed an object
of the appropriate type.

@defun eieio-build-class-alist &optional base-class
Returns an alist of all currently defined classes.  This alist is
suitable for completion lists used by interactive functions to select a
class.  The optional argument @var{base-class} allows the programmer to
select only a subset of classes to choose from should it prove
necessary.
@end defun

@node Association Lists, Introspection, Predicates, Top
@chapter Association Lists

Lisp offers the concept of association lists, with primitives such as
@code{assoc} used to access them.  Eieio provides a few such functions
to help with using lists of objects easily.

@defun object-assoc key field list
Returns the first object in @var{list} for which @var{key} is in
@var{field}.
@end defun

@defun object-assoc-list field list
Return an association list generated by extracting @var{field} from all
objects in @var{list}.  For each element of @var{list} the @code{car} is
the value of @var{field}, and the @code{cdr} is the object it was
extracted from.  This is useful for generating completion tables.
@end defun

@node Introspection, Signals, Association Lists, Top
@chapter Introspection

Introspection permits a programmer to peek at the contents of a class
without any previous knowledge of that class.  While EIEIO implements
objects on top of vectors, and thus everything is technically visible,
some functions have been provided.  None of these functions are a part
of CLOS.

@defun obj-fields obj
Return the list of public slots for @var{obj}.
@end defun

@defun class-slot-initarg class slot
For the given @var{class} return the :initarg associated with
@var{slot}.  Not all slots have initargs, so the return value can be
nil.
@end defun

@node Signals, Browsing, Introspection, Top
@comment  node-name,  next,  previous,  up
@chapter Signals

There are new signal types that can be caught when using eieio.

@deffn Signal invalid-slot-name obj-or-class field
This signal is called when an attempt to reference a slot in an
@var{obj-or-class} is made, and the @var{field} is not defined for
it.
@end deffn

@deffn Signal no-method-definition method arguments
This signal is called when @var{method} is called, with @var{arguments}
and nothing is resolved.  This occurs when @var{method} has been
defined, but the arguments make it impossible for eieio to determine
which method body to run.
@end deffn

@node Browsing, Class Values, Signals, Top
@comment  node-name,  next,  previous,  up
@chapter Browsing class trees

To browse all the currently loaded classes in emacs, simply run the
EIEIO browser.  @kbd{M-x eieio-browse}.  This browses all the way from
the default super-duper class eieio-default-superclass, and lists all
children in an indented tree structure.

To browse only from a specific class, pass it in as an alternate
parameter.

Here is a sample tree from our current example:

@example
eieio-default-superclass
  +--data-object
       +--data-object-symbol
@end example

Note that we start with eieio-default-superclass.  @xref{Default Superclass}.

Note: new classes are consed into the inheritance lists, so the tree
comes out upside-down.

It is also possible to use the function @code{eieio-class-tree} in the
@file{tree.el} package.  This will create an interactive tree.  Clicking
on nodes will allow expansion/contraction of branches, or editing of a
class.  @xref{Class Values}.

@node Class Values, Customizing, Browsing, Top
@comment  node-name,  next,  previous,  up
@chapter Class Values

Details about any class or object can be retrieved using the function
@code{eieio-describe-class} function.  Interactivly, type in the name of
a class.  In a program, pass it a string with the name of a class, a
class symbol, or an object.  The resulting buffer will display all field
names and their default values.  For objects, and additional column
representing current value of that field is also displayed.

The display is broken into two sections.  Private parts and public
parts.  Faces are used when available.  If the function
`eieio-class-tree' is used (from tree.el) then choosing the edit
function on a node calls this function.  This function is also useful
when used with edebug while attempting to determine what is wrong with
method.

@node Customizing, Documentation, Class Values, Top
@comment node-name, next, previous, up
@chapter Customizing Objects

In Emacs 20 a useful customization utility became available called
`custom'.  EIEIO supports custom through two new widget types.  If a
variable is declaired as type @code{'object}, then full editing of slots
via the widgets is made possible.  This should be used carefully,
however, because objects modified are cloned, so if there are other
references to these objects, they will no longer be linked together.

If you want in place editing of objects, use the following methods:

@defun eieio-customize-object object
Create a custom buffer and insert a widget for editing @var{object}.  At
the end, an @code{Apply} and @code{Reset} button are available.  This
will edit the object "in place" so references to it are also changed.
There is no effort to prevent multiple edits of a singular object, so
care must be taken by the user of this function.
@end defun

@defun eieio-custom-widget-insert object flags
This method inserts an edit object into the current buffer in place.
It's sole code is @code{(widget-create 'object-edit :value object)} and
is provided as a locale for adding tracking, or specializing the widget
insert procedure for any object.
@end defun

To define a slot with an object in it, use the @code{object} tag.  This
widget type will be automatically converted to @code{object-edit} if you
do in place editing of you object.

If you want to have additional actions taken when a user clicks on the
@code{Apply} button, then overload the method @code{eieio-done-customizing}.
This method does nothing by default, but that may change in the future.
This would be the best way to make your objects persistent when using
in-place editing.

@node Documentation, Demo Programs, Customizing, Top
@comment  node-name,  next,  previous,  up
@chapter Documentation

It is possible to automatically create documentation for your classes in
texinfo format by using the tools in the file @file{eieio-doc.el}

@deffn Command eieiodoc-class class indexstring &optional skiplist

This will start at the current point, and created an indented menu of
all the child classes of, and including @var{class}, but skipping any
classes that might be in @var{skiplist} It will then create nodes for
all these classes, subsection headings, and indexes.

Each class will be indexed using the texinfo labeled index
@var{indexstring} which is a two letter description.
@xref{(texinfo) New Indices}.

To use this command, the texinfo macro

@example
@@defindex @@var @{ indexstring @}
@end example

@noindent
where @var{indexstring} is replaced with the two letter code.

Next, an inheritance tree will be created listing all parents of that
section's class.

Then,all the slots will be expanded in tables, and described
using the documentation strings from the code.  Default values will also
be displayed.  Only those slots with @code{:initarg} specified will be
expanded, others will be hidden.  If a slot is inherited from a parent,
that slot will also be skipped unless the default value is different.
If there is a change, then the documentation part of the slot will be
replace with an @@xref back to the parent.

Only classes loaded into emacs' memory can be documented.

@end deffn

@node Demo Programs, Function Index, Documentation, Top
@comment  node-name,  next,  previous,  up
@chapter Demo Programs

There are many sample programs I have written for eieio which could
become useful componants of other applications, or are good stand alone
programs providing some useful functionality.  The file, and
functionality of these appear below:

@table @code
@item tree
Maintains and displays a tree structure in a buffer.  Nodes in the tree
can be clicked on for editing, node expansion, and simple information.
Includes a sample program for showing directory trees, and to draw trees
of the eieio class structures.
@item call-tree
Parses a non-byte-compiled function, and generates a call tree from it,
and all sub-non-byte-compiled functions.  Provides protection from
recursive functions.
@item chart
Draw bar charts from data.  Examples include displaying sizes of emacs
values, file distribution, and rmail distributions.
@item dbif
Database interface object for emacs.  So far, on psql (PostgreSQL) is
supported with @file{psql.el}
@end table

@node Function Index,  , Demo Programs, Top
@unnumbered Function Index

@printindex fn

@contents
@bye
